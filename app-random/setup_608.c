/* 
 *  Setup ATECC608 device 
 */


#include <string.h>  // strlen
#include <stdio.h>   // printf
#include "atca_config.h"
#include "cryptoauthlib.h"
#include "device_cfg.h"

/* Read a character and flush the stdin */
char getkey(void) {
    char v, d; // valid / discarded
    v = getchar();
    while((d = getchar()) != '\n' && d != EOF);
    return v;
}


int main(void) {
    char ch;
    ATCA_STATUS status;
    uint8_t text_buffer[128*5];
    size_t text_size = sizeof(text_buffer);
    uint8_t config_buffer[sizeof(atecc608_config_t)];
    atecc608_config_t *config_data = (atecc608_config_t *) config_buffer;

    // initialize CryptoAuthLib for an ECC default I2C interface
    if (atcab_init(&cfg_atecc608_i2c) != ATCA_SUCCESS) {
        printf("Init error\n");
        exit(1);
    }


    // TODO: check device ECC


    // Read config data
    //  88 bytes for ATSHA devices, 128 bytes for ATECC devices and 48 bytes for Trust Anchor devices.
    if (atcab_read_config_zone(config_buffer) != ATCA_SUCCESS) {
        printf("Error reading config\n");
        exit(1);
    }

    atcab_bin2hex(config_buffer, sizeof(config_buffer), text_buffer, &text_size);

    puts("");
    puts("Current config data:");
    puts(text_buffer);
    puts("");


    // TODO: Check config locked


    int slot = 0;

    // --------------
    // Slot 00: ECC external/internal private key, ECDH output clear, regenerable
    config_data->SlotConfig[slot] = 
        ATCA_SLOT_CONFIG_EXT_SIG_MASK      // External signatures of arbitrary messages are enabled.
      | ATCA_SLOT_CONFIG_INT_SIG_MASK      // Internal signatures of messages generated by GenDig or GenKey are enabled.
      | ATCA_SLOT_CONFIG_ECDH_MASK         // ECDH operation is permitted for this key.
      | ATCA_SLOT_CONFIG_IS_SECRET_MASK    // The contents of this slot are secret
      | ATCA_SLOT_CONFIG_GEN_KEY_MASK      // GenKey may be used to write random keys into this slot.
      ;

    config_data->KeyConfig[slot] = 
        ATCA_KEY_CONFIG_PRIVATE_MASK       // The key slot contains an ECC private key
      | ATCA_KEY_CONFIG_PUB_INFO_MASK      // The public version of this key can always be generated.
      | ATCA_KEY_CONFIG_KEY_TYPE(ATCA_P256_KEY_TYPE)        // 4: P256 NIST ECC key / 6: AES-128 key / 7: Not an ECC key
      | ATCA_KEY_CONFIG_LOCKABLE_MASK      // Slot can be individually locked using the Lock command.
      | ATCA_KEY_CONFIG_REQ_RANDOM_MASK    // A random nonce is required.
      ;

    printf("[%02d]  SlotConfig: %04x   KeyConfig: %04x\n", 
        slot, 
        config_data->SlotConfig[slot], 
        config_data->KeyConfig[slot]);

    slot++;

    // --------------
    // --------------
    // Slot 01: AES key
    
    // General Purpose Slot Config (Not ECC Private Keys)
    config_data->SlotConfig[slot] = 
        ATCA_SLOT_CONFIG_READKEY(7)        // Use this KeyID to encrypt data read from this slot. 0 only for CheckMac/Copy
      | ATCA_SLOT_CONFIG_ENC_READ_MASK     // Reads from this slot will be encrypted. IsSecret must also be set
      | ATCA_SLOT_CONFIG_IS_SECRET_MASK    // The contents of this slot are secret
      | ATCA_SLOT_CONFIG_WRITE_KEY(7)      // Use this key to validate and encrypt data written to this slot
      | ATCA_SLOT_CONFIG_WRITE_CONFIG(0b0111)   // Encrypted write, derive key from parent
      ;

    // Key Config
    config_data->KeyConfig[slot] = 
        ATCA_KEY_CONFIG_KEY_TYPE(ATCA_AES_KEY_TYPE) // Key type
      | ATCA_KEY_CONFIG_LOCKABLE_MASK      // Slot can be individually locked using the Lock command.
      | ATCA_KEY_CONFIG_REQ_RANDOM_MASK    // A random nonce is required.
      ;

    printf("[%02d]  SlotConfig: %04x   KeyConfig: %04x\n", 
        slot, 
        config_data->SlotConfig[slot], 
        config_data->KeyConfig[slot]);

    slot++;

    // --------------
    // --------------
    // Slot 02: AES key, limited uses
    
    // General Purpose Slot Config (Not ECC Private Keys)
    config_data->SlotConfig[slot] = 
        ATCA_SLOT_CONFIG_READKEY(7)        // Use this KeyID to encrypt data read from this slot. 0 only for CheckMac/Copy
      | ATCA_SLOT_CONFIG_ENC_READ_MASK     // Reads from this slot will be encrypted. IsSecret must also be set
      | ATCA_SLOT_CONFIG_LIMITED_USE_MASK  // The key stored in the slot is Limited Use.
      | ATCA_SLOT_CONFIG_IS_SECRET_MASK    // The contents of this slot are secret
      | ATCA_SLOT_CONFIG_WRITE_KEY(7)      // Use this key to validate and encrypt data written to this slot
      | ATCA_SLOT_CONFIG_WRITE_CONFIG(0b0111)   // Encrypted write, derive key from parent
      ;

    // Key Config
    config_data->KeyConfig[slot] = 
        ATCA_KEY_CONFIG_KEY_TYPE(ATCA_AES_KEY_TYPE)        // 4: P256 NIST ECC key / 6: AES-128 key / 7: Not an ECC key
      | ATCA_KEY_CONFIG_LOCKABLE_MASK      // Slot can be individually locked using the Lock command.
      | ATCA_KEY_CONFIG_REQ_RANDOM_MASK    // A random nonce is required.
      ;

    printf("[%02d]  SlotConfig: %04x   KeyConfig: %04x\n", 
        slot, 
        config_data->SlotConfig[slot], 
        config_data->KeyConfig[slot]);

    slot++;


    // --------------
    // --------------
    // Slot 03: AES key, debug
    
    // General Purpose Slot Config (Not ECC Private Keys)
    config_data->SlotConfig[slot] = 
        ATCA_SLOT_CONFIG_READKEY(7)       // Use this KeyID to encrypt data read from this slot. 0 only for CheckMac/Copy
      | ATCA_SLOT_CONFIG_WRITE_KEY(7)     // Use this key to validate and encrypt data written to this slot
      | ATCA_SLOT_CONFIG_WRITE_CONFIG(0)   // Always read/write
      ;

    // Key Config
    config_data->KeyConfig[slot] = 
        ATCA_KEY_CONFIG_KEY_TYPE(ATCA_AES_KEY_TYPE)        // 4: P256 NIST ECC key / 6: AES-128 key / 7: Not an ECC key
      ;

    printf("[%02d]  SlotConfig: %04x   KeyConfig: %04x\n", 
        slot, 
        config_data->SlotConfig[slot], 
        config_data->KeyConfig[slot]);

    slot++;


    // --------------
    // --------------
    // Slot 04: SHA secret
    
    // General Purpose Slot Config (Not ECC Private Keys)
    config_data->SlotConfig[slot] = 
        ATCA_SLOT_CONFIG_READKEY(7)        // Use this KeyID to encrypt data read from this slot. 0 only for CheckMac/Copy
      | ATCA_SLOT_CONFIG_ENC_READ_MASK     // Reads from this slot will be encrypted. IsSecret must also be set
      | ATCA_SLOT_CONFIG_IS_SECRET_MASK    // The contents of this slot are secret
      | ATCA_SLOT_CONFIG_WRITE_KEY(7)      // Use this key to validate and encrypt data written to this slot
      | ATCA_SLOT_CONFIG_WRITE_CONFIG(0b0111)   // Encrypted write, derive key from parent
      ;

    // Key Config
    config_data->KeyConfig[slot] = 
        ATCA_KEY_CONFIG_KEY_TYPE(ATCA_SHA_KEY_TYPE)        // 4: P256 NIST ECC key / 6: AES-128 key / 7: Not an ECC key
      | ATCA_KEY_CONFIG_LOCKABLE_MASK      // Slot can be individually locked using the Lock command.
      | ATCA_KEY_CONFIG_REQ_RANDOM_MASK    // A random nonce is required.
      ;

    printf("[%02d]  SlotConfig: %04x   KeyConfig: %04x\n", 
        slot, 
        config_data->SlotConfig[slot], 
        config_data->KeyConfig[slot]);

    slot++;

    // --------------
    // --------------
    // Slot 05: SHA secret, limited uses
    
    // General Purpose Slot Config (Not ECC Private Keys)
    config_data->SlotConfig[slot] = 
        ATCA_SLOT_CONFIG_READKEY(7)        // Use this KeyID to encrypt data read from this slot. 0 only for CheckMac/Copy
      | ATCA_SLOT_CONFIG_ENC_READ_MASK     // Reads from this slot will be encrypted. IsSecret must also be set
      | ATCA_SLOT_CONFIG_LIMITED_USE_MASK  // The key stored in the slot is Limited Use.
      | ATCA_SLOT_CONFIG_IS_SECRET_MASK    // The contents of this slot are secret
      | ATCA_SLOT_CONFIG_WRITE_KEY(7)      // Use this key to validate and encrypt data written to this slot
      | ATCA_SLOT_CONFIG_WRITE_CONFIG(0b0111)   // Encrypted write, derive key from parent
      ;

    // Key Config
    config_data->KeyConfig[slot] = 
        ATCA_KEY_CONFIG_KEY_TYPE(ATCA_SHA_KEY_TYPE)        // 4: P256 NIST ECC key / 6: AES-128 key / 7: Not an ECC key
      | ATCA_KEY_CONFIG_LOCKABLE_MASK      // Slot can be individually locked using the Lock command.
      | ATCA_KEY_CONFIG_REQ_RANDOM_MASK    // A random nonce is required.
      ;

    printf("[%02d]  SlotConfig: %04x   KeyConfig: %04x\n", 
        slot, 
        config_data->SlotConfig[slot], 
        config_data->KeyConfig[slot]);

    slot++;

    // --------------
    // --------------
    // Slot 06: SHA secret, debug
    
    // General Purpose Slot Config (Not ECC Private Keys)
    config_data->SlotConfig[slot] = 
        ATCA_SLOT_CONFIG_READKEY(7)        // Use this KeyID to encrypt data read from this slot. 0 only for CheckMac/Copy
      | ATCA_SLOT_CONFIG_WRITE_KEY(7)      // Use this key to validate and encrypt data written to this slot
      | ATCA_SLOT_CONFIG_WRITE_CONFIG(0)   // Always read/write
      ;

    // Key Config
    config_data->KeyConfig[slot] = 
        ATCA_KEY_CONFIG_KEY_TYPE(ATCA_SHA_KEY_TYPE)        // 4: P256 NIST ECC key / 6: AES-128 key / 7: Not an ECC key
      ;

    printf("[%02d]  SlotConfig: %04x   KeyConfig: %04x\n", 
        slot, 
        config_data->SlotConfig[slot], 
        config_data->KeyConfig[slot]);

    slot++;

    // --------------
    // --------------
    // Slot 07: SHA secret for IO key
    
    // General Purpose Slot Config (Not ECC Private Keys)
    config_data->SlotConfig[slot] = 
        ATCA_SLOT_CONFIG_READKEY(7)        // Use this KeyID to encrypt data read from this slot. 0 only for CheckMac/Copy
      | ATCA_SLOT_CONFIG_IS_SECRET_MASK    // The contents of this slot are secret
      | ATCA_SLOT_CONFIG_WRITE_KEY(7)      // Use this key to validate and encrypt data written to this slot
      | ATCA_SLOT_CONFIG_WRITE_CONFIG(0)   // Clear W
      ;

    // Key Config
    config_data->KeyConfig[slot] = 
        ATCA_KEY_CONFIG_KEY_TYPE(ATCA_SHA_KEY_TYPE)        // 4: P256 NIST ECC key / 6: AES-128 key / 7: Not an ECC key
      | ATCA_KEY_CONFIG_LOCKABLE_MASK      // Slot can be individually locked using the Lock command.
      | ATCA_KEY_CONFIG_REQ_RANDOM_MASK    // A random nonce is required.
      ;

    printf("[%02d]  SlotConfig: %04x   KeyConfig: %04x\n", 
        slot, 
        config_data->SlotConfig[slot], 
        config_data->KeyConfig[slot]);

    slot++;

    // --------------
    // --------------
    // Slot 08: Data
    
    // General Purpose Slot Config (Not ECC Private Keys)
    config_data->SlotConfig[slot] = 
        ATCA_SLOT_CONFIG_READKEY(7)        // Use this KeyID to encrypt data read from this slot. 0 only for CheckMac/Copy
      | ATCA_SLOT_CONFIG_WRITE_KEY(7)      // Use this key to validate and encrypt data written to this slot
      | ATCA_SLOT_CONFIG_WRITE_CONFIG(0)   // Clear W
      ;

    // Key Config
    config_data->KeyConfig[slot] = 
        ATCA_KEY_CONFIG_KEY_TYPE(ATCA_SHA_KEY_TYPE)        // 4: P256 NIST ECC key / 6: AES-128 key / 7: Not an ECC key
      | ATCA_KEY_CONFIG_LOCKABLE_MASK      // Slot can be individually locked using the Lock command.
      ;

    printf("[%02d]  SlotConfig: %04x   KeyConfig: %04x\n", 
        slot, 
        config_data->SlotConfig[slot], 
        config_data->KeyConfig[slot]);

    slot++;

    // --------------
    // --------------
    // Slot 09: Public key of slot 00
    
    // General Purpose Slot Config (Not ECC Private Keys)
    config_data->SlotConfig[slot] = 
        ATCA_SLOT_CONFIG_READKEY(7)        // Use this KeyID to encrypt data read from this slot. 0 only for CheckMac/Copy
      | ATCA_SLOT_CONFIG_WRITE_KEY(7)      // Use this key to validate and encrypt data written to this slot
      | ATCA_SLOT_CONFIG_WRITE_CONFIG(0)   // Clear W
      ;

    // Key Config
    config_data->KeyConfig[slot] = 
        ATCA_KEY_CONFIG_KEY_TYPE(4)        // 4: P256 NIST ECC key / 6: AES-128 key / 7: Not an ECC key
      | ATCA_KEY_CONFIG_LOCKABLE_MASK      // Slot can be individually locked using the Lock command.
      ;

    printf("[%02d]  SlotConfig: %04x   KeyConfig: %04x\n", 
        slot, 
        config_data->SlotConfig[slot], 
        config_data->KeyConfig[slot]);

    slot++;

    // --------------
    // --------------
    // Slot 10: SHA secret Checkmac/copy source
    
    // General Purpose Slot Config (Not ECC Private Keys)
    config_data->SlotConfig[slot] = 
        ATCA_SLOT_CONFIG_READKEY(0)        // Use this KeyID to encrypt data read from this slot. 0 only for CheckMac/Copy
      | ATCA_SLOT_CONFIG_ENC_READ_MASK     // Reads from this slot will be encrypted. IsSecret must also be set
      | ATCA_SLOT_CONFIG_IS_SECRET_MASK    // The contents of this slot are secret
      | ATCA_SLOT_CONFIG_WRITE_KEY(7)      // Use this key to validate and encrypt data written to this slot
      | ATCA_SLOT_CONFIG_WRITE_CONFIG(0)   // Clear W
      ;

    // Key Config
    config_data->KeyConfig[slot] = 
        ATCA_KEY_CONFIG_KEY_TYPE(ATCA_SHA_KEY_TYPE)        // 4: P256 NIST ECC key / 6: AES-128 key / 7: Not an ECC key
      | ATCA_KEY_CONFIG_LOCKABLE_MASK      // Slot can be individually locked using the Lock command.
      ;

    printf("[%02d]  SlotConfig: %04x   KeyConfig: %04x\n", 
        slot, 
        config_data->SlotConfig[slot], 
        config_data->KeyConfig[slot]);

    slot++;

    // --------------
    // --------------
    // Slot 11: SHA secret Checkmac/copy target
    
    // General Purpose Slot Config (Not ECC Private Keys)
    config_data->SlotConfig[slot] = 
        ATCA_SLOT_CONFIG_READKEY(0)        // Use this KeyID to encrypt data read from this slot. 0 only for CheckMac/Copy
      | ATCA_SLOT_CONFIG_ENC_READ_MASK     // Reads from this slot will be encrypted. IsSecret must also be set
      | ATCA_SLOT_CONFIG_IS_SECRET_MASK    // The contents of this slot are secret
      | ATCA_SLOT_CONFIG_WRITE_KEY(15)      // Use this key to validate and encrypt data written to this slot
      | ATCA_SLOT_CONFIG_WRITE_CONFIG(0)   // Clear W
      ;

    // Key Config
    config_data->KeyConfig[slot] = 
        ATCA_KEY_CONFIG_KEY_TYPE(ATCA_SHA_KEY_TYPE)        // 4: P256 NIST ECC key / 6: AES-128 key / 7: Not an ECC key
      | ATCA_KEY_CONFIG_LOCKABLE_MASK      // Slot can be individually locked using the Lock command.
      ;

    printf("[%02d]  SlotConfig: %04x   KeyConfig: %04x\n", 
        slot, 
        config_data->SlotConfig[slot], 
        config_data->KeyConfig[slot]);

    slot++;

    // --------------
    // --------------
    // Slot 12: Secret AES key authorized by key 13
    
    // General Purpose Slot Config (Not ECC Private Keys)
    config_data->SlotConfig[slot] = 
        ATCA_SLOT_CONFIG_READKEY(13)        // Use this KeyID to encrypt data read from this slot. 0 only for CheckMac/Copy
      | ATCA_SLOT_CONFIG_NOMAC_MASK        // The key stored in the slot cannot be used by the MAC or HMAC commands. 
      | ATCA_SLOT_CONFIG_IS_SECRET_MASK    // The contents of this slot are secret
      | ATCA_SLOT_CONFIG_WRITE_KEY(13)      // Use this key to validate and encrypt data written to this slot
      | ATCA_SLOT_CONFIG_WRITE_CONFIG(0b1011)  // Authorizing MAC required for DeriveKey command. (Create)
      ;

    // Key Config
    config_data->KeyConfig[slot] = 
        ATCA_KEY_CONFIG_KEY_TYPE(ATCA_AES_KEY_TYPE)        // 4: P256 NIST ECC key / 6: AES-128 key / 7: Not an ECC key
      | ATCA_KEY_CONFIG_LOCKABLE_MASK      // Slot can be individually locked using the Lock command.
      | ATCA_KEY_CONFIG_REQ_AUTH_MASK      // To use this key, authorization by AuthKey must be completed
      | ATCA_KEY_CONFIG_AUTH_KEY(13)        // If ReqAuth is one, this field points to the key that must be used for authorization 
      ;

    printf("[%02d]  SlotConfig: %04x   KeyConfig: %04x\n", 
        slot, 
        config_data->SlotConfig[slot], 
        config_data->KeyConfig[slot]);

    slot++;

    // --------------
    // --------------
    // Slot 13: SHA secret to use key 12. Can be changed if it is known.
    
    // General Purpose Slot Config (Not ECC Private Keys)
    config_data->SlotConfig[slot] = 
        ATCA_SLOT_CONFIG_READKEY(13)        // Use this KeyID to encrypt data read from this slot. 0 only for CheckMac/Copy
      | ATCA_SLOT_CONFIG_IS_SECRET_MASK    // The contents of this slot are secret
      | ATCA_SLOT_CONFIG_WRITE_KEY(13)      // Use this key to validate and encrypt data written to this slot
      | ATCA_SLOT_CONFIG_WRITE_CONFIG(0b0100)   // Encrypt write (with itself)
      ;

    // Key Config
    config_data->KeyConfig[slot] = 
        ATCA_KEY_CONFIG_KEY_TYPE(ATCA_SHA_KEY_TYPE)        // 4: P256 NIST ECC key / 6: AES-128 key / 7: Not an ECC key
      | ATCA_KEY_CONFIG_LOCKABLE_MASK      // Slot can be individually locked using the Lock command.
      | ATCA_KEY_CONFIG_REQ_RANDOM_MASK    // A random nonce is required.
      ;

    printf("[%02d]  SlotConfig: %04x   KeyConfig: %04x\n", 
        slot, 
        config_data->SlotConfig[slot], 
        config_data->KeyConfig[slot]);

    slot++;

    // --------------
    // --------------
    // Slot 14: Foreign Public key
    
    // General Purpose Slot Config (Not ECC Private Keys)
    config_data->SlotConfig[slot] = 
        ATCA_SLOT_CONFIG_READKEY(7)        // Use this KeyID to encrypt data read from this slot. 0 only for CheckMac/Copy
      | ATCA_SLOT_CONFIG_WRITE_KEY(7)      // Use this key to validate and encrypt data written to this slot
      | ATCA_SLOT_CONFIG_WRITE_CONFIG(0)   // Clear W
      ;

    // Key Config
    config_data->KeyConfig[slot] = 
        ATCA_KEY_CONFIG_KEY_TYPE(ATCA_P256_KEY_TYPE)        // 4: P256 NIST ECC key / 6: AES-128 key / 7: Not an ECC key
      | ATCA_KEY_CONFIG_LOCKABLE_MASK      // Slot can be individually locked using the Lock command.
      ;

    printf("[%02d]  SlotConfig: %04x   KeyConfig: %04x\n", 
        slot, 
        config_data->SlotConfig[slot], 
        config_data->KeyConfig[slot]);

    slot++;

    // --------------
    // --------------
    // Slot 15: Data (ATECC608 does not support slot 15 limited use like ATECC508)
    
    // General Purpose Slot Config (Not ECC Private Keys)
    config_data->SlotConfig[slot] = 
        ATCA_SLOT_CONFIG_WRITE_KEY(7)      // Use this key to validate and encrypt data written to this slot
      | ATCA_SLOT_CONFIG_WRITE_CONFIG(0b0100)   // Encrypted W
      ;

    // Key Config
    config_data->KeyConfig[slot] = 
        ATCA_KEY_CONFIG_KEY_TYPE(ATCA_SHA_KEY_TYPE)        // 4: P256 NIST ECC key / 6: AES-128 key / 7: Not an ECC key
      | ATCA_KEY_CONFIG_LOCKABLE_MASK      // Slot can be individually locked using the Lock command.
      ;

    printf("[%02d]  SlotConfig: %04x   KeyConfig: %04x\n", 
        slot, 
        config_data->SlotConfig[slot], 
        config_data->KeyConfig[slot]);

    slot++;

    // --------------


/* Slot Template

    // --------------
    // Slot: <description>
    
    // General Purpose Slot Config (Not ECC Private Keys)
    config_data->SlotConfig[slot] = 
        ATCA_SLOT_CONFIG_READKEY(v)        // Use this KeyID to encrypt data read from this slot. 0 only for CheckMac/Copy
      | ATCA_SLOT_CONFIG_NOMAC_MASK        // The key stored in the slot cannot be used by the MAC or HMAC commands. 
      | ATCA_SLOT_CONFIG_LIMITED_USE_MASK  // The key stored in the slot is Limited Use.
      | ATCA_SLOT_CONFIG_ENC_READ_MASK     // Reads from this slot will be encrypted. IsSecret must also be set
      | ATCA_SLOT_CONFIG_IS_SECRET_MASK    // The contents of this slot are secret
      | ATCA_SLOT_CONFIG_WRITE_KEY(v)      // Use this key to validate and encrypt data written to this slot
      | ATCA_SLOT_CONFIG_WRITE_CONFIG(v)   // See Table 2-8, Table 2-9, Table 2-10, Table 2-11, and Write Command.
      ;

    // Slot Config for ECC Private Keys
    config_data->SlotConfig[slot] = 
        ATCA_SLOT_CONFIG_EXT_SIG_MASK      // External signatures of arbitrary messages are enabled.
      | ATCA_SLOT_CONFIG_INT_SIG_MASK      // Internal signatures of messages generated by GenDig or GenKey are enabled.
      | ATCA_SLOT_CONFIG_ECDH_MASK         // ECDH operation is permitted for this key.
      | ATCA_SLOT_CONFIG_WRITE_ECDH_MASK   // Master secret will be written into slot N+1. (vs. output on the clear)
      | ATCA_SLOT_CONFIG_IS_SECRET_MASK    // The contents of this slot are secret
      | ATCA_SLOT_CONFIG_GEN_KEY_MASK      // GenKey may be used to write random keys into this slot.
      | ATCA_SLOT_CONFIG_PRIV_WRITE_MASK   // Encrypted PrivWrite command allowed.
      ;

    // Key Config
    config_data->KeyConfig[slot] = 
        ATCA_KEY_CONFIG_PRIVATE_MASK       // The key slot contains an ECC private key
      | ATCA_KEY_CONFIG_PUB_INFO_MASK      // The public version of this key can always be generated.
      | ATCA_KEY_CONFIG_KEY_TYPE(v)        // 4: P256 NIST ECC key / 6: AES-128 key / 7: Not an ECC key
      | ATCA_KEY_CONFIG_LOCKABLE_MASK      // Slot can be individually locked using the Lock command.
      | ATCA_KEY_CONFIG_REQ_RANDOM_MASK    // A random nonce is required.
      | ATCA_KEY_CONFIG_REQ_AUTH_MASK      // To use this key, authorization by AuthKey must be completed
      | ATCA_KEY_CONFIG_AUTH_KEY(v)        // If ReqAuth is one, this field points to the key that must be used for authorization 
      | ATCA_KEY_CONFIG_PERSIST_DIS_MASK   // Use of this key is prohibited for all commands other than GenKey if the IntrusionLatch is zero.
      | ATCA_KEY_CONFIG_RFU_MASK           // Reserved
      | ATCA_KEY_CONFIG_X509_ID(v)         // The index into the X509format array within the configuration zone which corresponds to this slot.
      ;

    printf("[%02d]  SlotConfig: %04x   KeyConfig: %04x\n", 
        slot, 
        config_data->SlotConfig[slot], 
        config_data->KeyConfig[slot]);

    slot++;

    // --------------
*/


    config_data->SlotLocked = 0xFFFF;  // unlock all lockable slots

    atcab_bin2hex(config_buffer, sizeof(config_buffer), text_buffer, &text_size);

    puts("");
    puts("Modified config data:");
    puts(text_buffer);
    puts("");

    printf("Write configuration? [y/n] ");
    ch = getkey();
    if (ch == 'y' || ch == 'Y') {
        if (status = atcab_write_config_zone (config_buffer) == ATCA_SUCCESS) {
            puts("Write OK");
        }
        else {
            printf("Write Error: 0x%02x\n", status);
            exit(1);
        }
    }


    // Counters
    status = atcab_write_config_counter(0, 1000);
    if (status == ATCA_SUCCESS) {
        puts("Write Counter0 OK");
    }
    else {
        printf("Write Counter0 Error: %d\n", status);
        //exit(1);
    }

    status = atcab_write_config_counter(1, 1000);
    if (status == ATCA_SUCCESS) {
        puts("Write Counter1 OK");
    }
    else {
        printf("Write Counter1 Error: %d\n", status);
        //exit(1);
    }


    // Lock config
    printf("Lock config now? [y/n] ");
    ch = getkey();
    if (ch == 'y' || ch == 'Y') {
        status = atcab_lock_config_zone();
        if (status == ATCA_SUCCESS) {
            puts("Lock config OK");
        }
        else {
            printf("Lock config error: %d\n", status);
            exit(1);
        }
    }


    // Write OTP
    uint8_t *otpdata = "1.0|2024/03/21|Electronica y Ciencia|www.electronicayciencia.com";

    status = atcab_write_bytes_zone(ATCA_ZONE_OTP, 0, 0, otpdata, 64);
    if (status == ATCA_SUCCESS) {
        puts("OTP write OK");
    }
    else {
        printf("OTP write error: %d\n", status);
        exit(1);
    }


    // Get a random number
    uint8_t random_number[32];
    uint8_t txt_buffer[32*5];
    size_t txt_buffer_size = sizeof(txt_buffer);

    atcab_random(random_number); // get a random number from the chip
    atcab_bin2hex(random_number, sizeof(random_number), txt_buffer, &txt_buffer_size);

    puts("");
    puts("Random output:");
    puts(txt_buffer);
    puts("");


    // Write random to slots 7 and 13
    status = atcab_write_bytes_zone(ATCA_ZONE_DATA, 7, 0, random_number, 32);
    if (status == ATCA_SUCCESS) {
        puts("Slot 7 write OK");
    }
    else {
        printf("Slot 7 write errorr: %d\n", status);
        exit(1);
    }

    status = atcab_write_bytes_zone(ATCA_ZONE_DATA, 13, 0, random_number, 32);
    if (status == ATCA_SUCCESS) {
        puts("Slot 13 write OK");
    }
    else {
        printf("Slot 13 write error: %d\n", status);
        exit(1);
    }

    // Lock data
    printf("Lock Data & OTP now? [y/n] ");
    ch = getkey();
    if (ch == 'y' || ch == 'Y') {
        status = atcab_lock_data_zone();
        if (status == ATCA_SUCCESS) {
            puts("Lock Data & OTP OK");
        }
        else {
            printf("Lock Data & OTP error: %d\n", status);
            exit(1);
        }
    }

    puts("Exit");

}

